#set($h2 = '##')
#set($h3 = '###')
$h2 Running and debugging

To run or debug your client-side code, use the [`gwt:codeserver`](codeserver-mojo.html) goal.
This is an aggregator goal, which means its configuration is done in your root POM, not in your `gwt-app` (in a multi-module setup).
This gives the goal the opportunity to use several `gwt-app` modules from the reactor (which it will do automatically by default).

Starting with GWT 2.7, you should set the `launcherDir` property to get _recompile on reload._
The property should point to a folder that you web server / servlet container will look into for web resources,
so that the `*.nocache.js` file generated by the CodeServer can be loaded by your web browser.
You can find sample configuration, in combination with the Tomcat and Jetty Maven Plugins,
in the archetypes at https://github.com/tbroyer/gwt-maven-archetypes/.
In older versions of GWT, you'd have to resort to bookmarklets from a version of your app that has been compiled (and deployed) once.

Because the goal will trigger the `process-classes` phase in all modules,
it's a good idea to only include client modules in the reactor build using Maven's `-pl` argument (and don't forget the `-am` too).
If you have several `gwt-app` modules, limiting the reactor build with only a subset of them will also automatically limit the ones ran through the CodeServer.
An alternative is to use the `projects` property (or `-Dgwt.projects=` on the command-line), which can be used in profiles for instance to create presets.

The `projects` property can also be used to run the CodeServer on modules which are not `gwt-app` (e.g. `war`).
You'd then probably use it in combination with the `modules` property to define the list of GWT modules to run through the CodeServer.
By default, the ${project.name} will look for the `moduleName` property in the projects
(whether given explicitly as `projects` or the discovered `gwt-app` modules from the reactor build),
which gives you an opportunity to configure it even in non-`gwt-app` projects.

Finally, note that because the CodeServer takes a different set of arguments from the GWT Compiler,
you'll have to define some arguments twice: both in `compilerArgs` for the GWT Compiler, and in `codeserverArgs` for the CodeServer.

$h3 Standalone applications

GWT's CodeServer is great for apps for which a server serves the HTML host page,
but not so well for standalone applications,
i.e. applications that only contain client-side code (offline, or using CORS).

For standalone applications, use the [`gwt:devmode`](devmode-mojo.html) goal instead of [`gwt:codeserver`](codeserver-mojo.html).

The goals works the same, except for a few configuration properties,
and the `warDir` (somewhat equivalent to `gwt:codeserver`'s `launcherDir`) property has a default value (and is mandatory).

You'll likely want to configure in `devmodeArgs` a `-startupUrl` argument pointing to an HTML host page living in the _public path_ of the module.
Have a look at the `gwt-app` integration test for an example.

Note: `gwt:devmode` can be configured for a webapp too
(provided you previously run `war:exploded` or equivalent on the server part of the application)
but this is discouraged as the webapp classloader in DevMode is somewhat broken.
